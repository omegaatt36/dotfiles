# ========== p10k instant prompt ==========
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# ========== mise (formerly rtx) ==========
# Initialize mise early to ensure paths are set up correctly
if command -v mise &> /dev/null; then
    eval "$(mise activate zsh)"
fi

# ========== oh-my-zsh ==========
export ZSH="${HOME}/.oh-my-zsh"
POWERLEVEL9K_MODE='nerdfont-complete'
ZSH_THEME="powerlevel10k/powerlevel10k"

export ZSH_WAKATIME_BIN=/usr/local/bin/wakatime-cli

plugins=(
    git
    zsh-syntax-highlighting
    zsh-autosuggestions
    history-substring-search
    fzf-tab
    wakatime
)

source $ZSH/oh-my-zsh.sh

# Function to lazy load completions
# Usage: lazy_load_completion_command "command_name" "alias_name_if_any" "completion_sourcing_command" "completion_function_name"
# Example: lazy_load_completion_command "kubectl" "k" "kubectl completion zsh" "_kubectl"
lazy_load_completion_command() {
  local cmd_name="$1"
  local alias_name="$2" # Can be empty if no alias or same as cmd_name
  local comp_src_cmd="$3"
  local comp_func_name="$4" # The function Zsh will call for completion, e.g., _kubectl

  if command -v "$cmd_name" &> /dev/null; then
    if [[ -n "$alias_name" && "$alias_name" != "$cmd_name" ]]; then
      alias "$alias_name"="$cmd_name"
    fi

    # Define the loader function dynamically
    # The name of this loader function will be, e.g., __lazy_loader_kubectl
    eval "
    __lazy_loader_${cmd_name}() {
      compdef -d \"$cmd_name\" # Deregister this loader for the main command
      if [[ -n \"$alias_name\" && \"$alias_name\" != \"$cmd_name\" ]]; then
        compdef -d \"$alias_name\" # Deregister for alias too
      fi
      source <($comp_src_cmd)
      # After sourcing, the actual completion function (e.g., _kubectl) should be defined.
      # We then call it.
      \$comp_func_name \"\$@\"
    }
    "
    compdef "__lazy_loader_${cmd_name}" "$cmd_name"
    if [[ -n "$alias_name" && "$alias_name" != "$cmd_name" ]]; then
      compdef "__lazy_loader_${cmd_name}" "$alias_name"
    fi
  fi
}

# ========== docker ==========
lazy_load_completion_command "docker" "dk" "docker completion zsh" "_docker"

# ========== kubectl ==========
lazy_load_completion_command "kubectl" "k" "kubectl completion zsh" "_kubectl"
# https://krew.sigs.k8s.io/docs/user-guide/setup/install/
export PATH="${KREW_ROOT:-$HOME/.krew}/bin:$PATH"

# ========== podman ==========
lazy_load_completion_command "podman" "" "podman completion zsh" "_podman"

# ========== colima ==========
if command -v colima &> /dev/null; then
  _colima_completion_loader() {
    compdef -d colima
    if colima status --profile k8s &> /dev/null; then
      source <(colima completion zsh)
      _colima "$@" # Assuming colima completion zsh defines _colima
    else
      # echo "Colima k8s profile not running, no completions." >&2 # Optional debug
      return 1 # Indicate completion failed
    fi
  }
  compdef _colima_completion_loader colima
fi

# ========== nerdctl ==========
lazy_load_completion_command "nerdctl" "nerd" "nerdctl completion zsh" "_nerdctl" # Assuming _nerdctl

# ========== taskfile =========
lazy_load_completion_command "task" "" "task --completion zsh" "_task" # Assuming _task

# ========== helm ==========
lazy_load_completion_command "helm" "" "helm completion zsh" "_helm"

# bind home & end key
bindkey "^[[H" beginning-of-line
bindkey "^[[F" end-of-line
alias zh_locale='
export LC_ALL=zh_TW.UTF-8
export LANG=zh_TW.UTF-8
export LANGUAGE=zh_TW.UTF-8
export LC_MESSAGE=zh_TW.UTF-8
export LC_TIME=zh_TW.UTF-8'

alias en_locale='
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export LANGUAGE=en_US.UTF-8
export LC_MESSAGE=en_US.UTF-8
export LC_TIME=en_US.UTF-8'

en_locale

# ========== fzf ==========
if command -v fzf &> /dev/null; then
   # Use fzf --zsh if available (fzf 0.48+)
   if fzf --zsh &> /dev/null; then
      eval "$(fzf --zsh)"
   elif [ -f ~/.fzf.zsh ]; then
      source ~/.fzf.zsh
   fi
fi

# ========== powerlevel10k ==========
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# tmux
export TMUX_PLUGIN_MANAGER_PATH=${HOME}/.tmux/plugins/tpm/

# golang
export GOROOT=/usr/local/go
export GOPATH=$HOME/go
export GOPROXY=https://proxy.golang.org,direct
export PATH=$PATH:$GOPATH/bin
[ -d "/usr/local/go/bin" ] && export PATH=$PATH:/usr/local/go/bin

# zen browser
export PATH=$PATH:/usr/local/zen

# npm
export PATH="${HOME}/.npm-global/bin":"${PATH}"

# rust
[ -f ${HOME}/.cargo/env ] && source ${HOME}/.cargo/env
if command -v bat &> /dev/null; then alias cat=bat; fi
if command -v eza &> /dev/null;
then
  alias ls="eza --icons=always"
  alias ll="eza --icons=always -lh"
  alias tree="eza --icons=always --tree"
fi

if command -v rg &> /dev/null; then alias grep=rg; fi

if command -v fzf &> /dev/null;
then
   eval "$(fzf --zsh)"
fi

if command -v zoxide &> /dev/null;
then
    eval "$(zoxide init zsh --cmd cd)"
fi

if command -v atuin &> /dev/null;
then
    eval "$(atuin init zsh)"
fi

# Clipboard configuration
if [[ "$OSTYPE" == "darwin"* ]]; then
    alias copy='pbcopy'
    alias paste='pbpaste'
else
    # Linux / Other
    if command -v wl-copy >/dev/null 2>&1; then
        alias copy='wl-copy'
        alias paste='wl-paste'
        alias pbcopy='wl-copy'
        alias pbpaste='wl-paste'
    elif command -v xclip >/dev/null 2>&1; then
        alias copy='xclip -selection clipboard -r'
        alias paste='xclip -selection clipboard -o'
        alias pbcopy='xclip -selection clipboard -r'
        alias pbpaste='xclip -selection clipboard -o'
    fi
fi


# ========== other env ==========
[[ ! -f ~/.zsh_other_env ]] || source ~/.zsh_other_env

# Unset the helper function if you don't need it elsewhere
unset -f lazy_load_completion_command

# Added by Antigravity
export PATH="/Users/raiven_kao/.antigravity/antigravity/bin:$PATH"
